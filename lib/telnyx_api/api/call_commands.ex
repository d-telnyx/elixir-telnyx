# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# https://openapi-generator.tech
# Do not edit the class manually.

defmodule TelnyxAPI.Api.CallCommands do
  @moduledoc """
  API calls for all endpoints tagged `CallCommands`.
  """

  alias TelnyxAPI.Connection
  import TelnyxAPI.RequestBuilder


  @doc """
  Answer call
  Answer an incoming call. You must issue this command before executing subsequent commands on an incoming call.  **Expected Webhooks:**  - `call.answered` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - answer_request (AnswerRequest): Answer call request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_answer(Tesla.Env.client, String.t, TelnyxAPI.Model.AnswerRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_answer(connection, call_control_id, answer_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/answer")
    |> add_param(:body, :body, answer_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Bridge calls
  Bridge two call control calls.  **Expected Webhooks:**  - `call.bridged` for Leg A - `call.bridged` for Leg B 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - bridge_request (BridgeRequest): Bridge call request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_bridge(Tesla.Env.client, String.t, TelnyxAPI.Model.BridgeRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_bridge(connection, call_control_id, bridge_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/bridge")
    |> add_param(:body, :body, bridge_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Dial
  Dial a number or SIP URI from a given connection. A successful response will include a `call_leg_id` which can be used to correlate the command with subsequent webhooks.  **Expected Webhooks:**  - `call.initiated` - `call.answered` or `call.hangup` - `call.machine.detection.ended` if `answering_machine_detection` was requested - `call.machine.greeting.ended` if `answering_machine_detection` was set to `detect_beep`, `greeting_end` or `detect_words`

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_request (CallRequest): Call request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.RetrieveCallStatusResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_dial(Tesla.Env.client, TelnyxAPI.Model.CallRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.RetrieveCallStatusResponse.t} | {:error, Tesla.Env.t}
  def call_dial(connection, call_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls")
    |> add_param(:body, :body, call_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.RetrieveCallStatusResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Enqueue call
  Put the call in a queue.

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - enqueue_request (EnqueueRequest): Enqueue call request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_enqueue(Tesla.Env.client, String.t, TelnyxAPI.Model.EnqueueRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_enqueue(connection, call_control_id, enqueue_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/enqueue")
    |> add_param(:body, :body, enqueue_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Forking start
  Call forking allows you to stream the media from a call to a specific target in realtime.  This stream can be used to enable realtime audio analysis to support a  variety of use cases, including fraud detection, or the creation of AI-generated audio responses.  Requests must specify either the `target` attribute or the `rx` and `tx` attributes.  **Expected Webhooks:**  - `call.fork.started` - `call.fork.stopped`  **Simple Telnyx RTP Encapsulation Protocol (STREP)**  *Note: This header/encapsulation is not used when the `rx` and `tx` parameters have been specified; it only applies when media is forked using the `target` attribute.*  If the destination for forked media is specified using the \"target\" attribute, the RTP will be encapsulated in an extra Telnyx protocol, which adds a 24 byte header to the RTP payload in each packet. The STREP header includes the Call Control `call_leg_id` for stream identification, along with bits that represent the direction (inbound or outbound) of the media. This 24-byte header sits between the UDP header and the RTP header.  The STREP header makes it possible to fork RTP for multiple calls (or two RTP streams for the same call) to the same IP:port, where the streams can be demultiplexed by your application using the information in the header. Of course, it's still possible to ignore this header completely, for example, if sending forked media for different calls to different ports or IP addresses. In this case, simply strip 24 bytes (or use the second byte to find the header length) from the received UDP payload to get the RTP (RTP header and payload).  ``` STREP Specification    0                   1                   2                   3   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |1 1|Version|L|D|    HeaderLen  |  reserved (2 bytes)           |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |       reserved (4 bytes, for UDP ports or anything else)      |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |               The call_leg_id                                 |  |                   from Call Control                           |  |                       (128 bits / 16 bytes)                   |  |                           (this is binary data)               |  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   11    Static bits 11, always set to 11 to easily distinguish forked media    from RTP (10) and T.38 media (usually 00) and SIP (which begins    with a capital letter, so begins with bits 01). This is a magic number.   Version    Four bits to indicate the version number of the protocol, starting at 0001.   L    One bit to represent the leg of the call (A or B).    0 represents the A (first) leg of the call.    1 represents the B (second) leg of the call.   D    One bit to represent the direction of this RTP stream.    0 represents media received by Telnyx.    1 represents media transmitted by Telnyx.   HeaderLen (1 byte)    The length of the header in bytes.    Note that this value does not include the length of the payload. The total    size of the RTP can be calculated by subtracting the HeaderLen from the UDP    length (minus 8 for the UDP header).    In version 1, this value will always be 24.   Reserved (6 bytes)    Reserved for future use and to make sure that the header is a multiple of 32 bits   Call Leg ID    A 128-bit identifier for the call leg.    This is the call_leg_id from Call Control. ``` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - start_forking_request (StartForkingRequest): Fork media request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_fork_start(Tesla.Env.client, String.t, TelnyxAPI.Model.StartForkingRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_fork_start(connection, call_control_id, start_forking_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/fork_start")
    |> add_param(:body, :body, start_forking_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Forking stop
  Stop forking a call.  **Expected Webhooks:**  - `call.fork.stopped` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - stop_forking_request (StopForkingRequest): Stop forking media request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_fork_stop(Tesla.Env.client, String.t, TelnyxAPI.Model.StopForkingRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_fork_stop(connection, call_control_id, stop_forking_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/fork_stop")
    |> add_param(:body, :body, stop_forking_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Gather stop
  Stop current gather.  **Expected Webhooks:**  - `call.gather.ended` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - stop_gather_request (StopGatherRequest): Stop current gather
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_gather_stop(Tesla.Env.client, String.t, TelnyxAPI.Model.StopGatherRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_gather_stop(connection, call_control_id, stop_gather_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/gather_stop")
    |> add_param(:body, :body, stop_gather_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Gather using audio
  Play an audio file on the call until the required DTMF signals are gathered to build interactive menus.  You can pass a list of valid digits along with an 'invalid_audio_url', which will be played back at the beginning of each prompt. Playback will be interrupted when a DTMF signal is received. The [Answer](/docs/api/v2/call-control/Call-Commands#CallControlAnswer) command must be issued before the `gather_using_audio` command.  **Expected Webhooks:**  - `call.playback.started` - `call.playback.ended` - `call.dtmf.received` (you may receive many of these webhooks) - `call.gather.ended` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - gather_using_audio_request (GatherUsingAudioRequest): Gather using audio request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_gather_using_audio(Tesla.Env.client, String.t, TelnyxAPI.Model.GatherUsingAudioRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_gather_using_audio(connection, call_control_id, gather_using_audio_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/gather_using_audio")
    |> add_param(:body, :body, gather_using_audio_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Gather using speak
  Convert text to speech and play it on the call until the required DTMF signals are gathered to build interactive menus.  You can pass a list of valid digits along with an 'invalid_payload', which will be played back at the beginning of each prompt. Speech will be interrupted when a DTMF signal is received. The [Answer](/docs/api/v2/call-control/Call-Commands#CallControlAnswer) command must be issued before the `gather_using_speak` command.  **Expected Webhooks:**  - `call.dtmf.received` (you may receive many of these webhooks) - `call.gather.ended` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - gather_using_speak_request (GatherUsingSpeakRequest): Gather using speak request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_gather_using_speak(Tesla.Env.client, String.t, TelnyxAPI.Model.GatherUsingSpeakRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_gather_using_speak(connection, call_control_id, gather_using_speak_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/gather_using_speak")
    |> add_param(:body, :body, gather_using_speak_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Hangup call
  Hang up the call.  **Expected Webhooks:**  - `call.hangup` - `call.recording.saved` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - hangup_request (HangupRequest): Hangup request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_hangup(Tesla.Env.client, String.t, TelnyxAPI.Model.HangupRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_hangup(connection, call_control_id, hangup_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/hangup")
    |> add_param(:body, :body, hangup_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Play audio URL
  Play an audio file on the call. If multiple play audio commands are issued consecutively, the audio files will be placed in a queue awaiting playback.  *Notes:*  - When `overlay` is enabled, `target_legs` is limited to `self`. - A customer cannot Play Audio with `overlay=true` unless there is a Play Audio with `overlay=false` actively playing.  **Expected Webhooks:**  - `call.playback.started` - `call.playback.ended` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - play_audio_url_request (PlayAudioUrlRequest): Play audio URL request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_playback_start(Tesla.Env.client, String.t, TelnyxAPI.Model.PlayAudioUrlRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_playback_start(connection, call_control_id, play_audio_url_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/playback_start")
    |> add_param(:body, :body, play_audio_url_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Stop audio playback
  Stop audio being played on the call.  **Expected Webhooks:**  - `call.playback.ended` or `call.speak.ended` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - playback_stop_request (PlaybackStopRequest): Stop audio playback request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_playback_stop(Tesla.Env.client, String.t, TelnyxAPI.Model.PlaybackStopRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_playback_stop(connection, call_control_id, playback_stop_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/playback_stop")
    |> add_param(:body, :body, playback_stop_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Record pause
  Pause recording the call. Recording can be resumed via Resume recording command.  **Expected Webhooks:**  There are no webhooks associated with this command. 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - pause_recording_request (PauseRecordingRequest): Pause recording call request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_record_pause(Tesla.Env.client, String.t, TelnyxAPI.Model.PauseRecordingRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_record_pause(connection, call_control_id, pause_recording_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/record_pause")
    |> add_param(:body, :body, pause_recording_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Record resume
  Resume recording the call.  **Expected Webhooks:**  There are no webhooks associated with this command. 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - resume_recording_request (ResumeRecordingRequest): Resume recording call request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_record_resume(Tesla.Env.client, String.t, TelnyxAPI.Model.ResumeRecordingRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_record_resume(connection, call_control_id, resume_recording_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/record_resume")
    |> add_param(:body, :body, resume_recording_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Recording start
  Start recording the call. Recording will stop on call hang-up, or can be initiated via the Stop Recording command.  **Expected Webhooks:**  - `call.recording.saved` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - start_recording_request (StartRecordingRequest): Start recording audio request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_record_start(Tesla.Env.client, String.t, TelnyxAPI.Model.StartRecordingRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_record_start(connection, call_control_id, start_recording_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/record_start")
    |> add_param(:body, :body, start_recording_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Recording stop
  Stop recording the call.  **Expected Webhooks:**  - `call.recording.saved` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - stop_recording_request (StopRecordingRequest): Stop recording call request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_record_stop(Tesla.Env.client, String.t, TelnyxAPI.Model.StopRecordingRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_record_stop(connection, call_control_id, stop_recording_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/record_stop")
    |> add_param(:body, :body, stop_recording_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  SIP Refer a call
  Initiate a SIP Refer on a Call Control call. You can initiate a SIP Refer at any point in the duration of a call.  **Expected Webhooks:**  - `call.refer.started` - `call.refer.completed` - `call.refer.failed` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - refer_request (ReferRequest): Refer request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_refer(Tesla.Env.client, String.t, TelnyxAPI.Model.ReferRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_refer(connection, call_control_id, refer_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/refer")
    |> add_param(:body, :body, refer_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Reject a call
  Reject an incoming call.  **Expected Webhooks:**  - `call.hangup` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - reject_request (RejectRequest): Reject request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_reject(Tesla.Env.client, String.t, TelnyxAPI.Model.RejectRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_reject(connection, call_control_id, reject_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/reject")
    |> add_param(:body, :body, reject_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Send DTMF
  Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the call.  **Expected Webhooks:**  There are no webhooks associated with this command. 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - send_dtmf_request (SendDtmfRequest): Send DTMF request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_send_dtmf(Tesla.Env.client, String.t, TelnyxAPI.Model.SendDtmfRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_send_dtmf(connection, call_control_id, send_dtmf_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/send_dtmf")
    |> add_param(:body, :body, send_dtmf_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Speak text
  Convert text to speech and play it back on the call. If multiple speak text commands are issued consecutively, the audio files will be placed in a queue awaiting playback.  **Expected Webhooks:**  - `call.speak.started` - `call.speak.ended` 

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - speak_request (SpeakRequest): Speak request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_speak(Tesla.Env.client, String.t, TelnyxAPI.Model.SpeakRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_speak(connection, call_control_id, speak_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/speak")
    |> add_param(:body, :body, speak_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Transcription start
  Start real-time transcription. Transcription will stop on call hang-up, or can be initiated via the Transcription stop command.

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - transcription_start_request (TranscriptionStartRequest): Transcription start request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_transcription_start(Tesla.Env.client, String.t, TelnyxAPI.Model.TranscriptionStartRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_transcription_start(connection, call_control_id, transcription_start_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/transcription_start")
    |> add_param(:body, :body, transcription_start_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Transcription stop
  Stop real-time transcription.

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - transcription_stop_request (TranscriptionStopRequest): Transcription stop request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_transcription_stop(Tesla.Env.client, String.t, TelnyxAPI.Model.TranscriptionStopRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_transcription_stop(connection, call_control_id, transcription_stop_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/transcription_stop")
    |> add_param(:body, :body, transcription_stop_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Transfer call
  Transfer a call to a new destination. If the transfer is unsuccessful, a `call.hangup` webhook for the other call (Leg B) will be sent indicating that the transfer could not be completed. The original call will remain active and may be issued additional commands, potentially transfering the call to an alternate destination.  **Expected Webhooks:**  - `call.initiated` - `call.bridged` to Leg B - `call.answered` or `call.hangup` - `call.machine.detection.ended` if `answering_machine_detection` was requested - `call.machine.greeting.ended` if `answering_machine_detection` was set to `detect_beep`, `greeting_end` or `detect_words`

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - transfer_call_request (TransferCallRequest): Transfer call request
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec call_transfer(Tesla.Env.client, String.t, TelnyxAPI.Model.TransferCallRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def call_transfer(connection, call_control_id, transfer_call_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/transfer")
    |> add_param(:body, :body, transfer_call_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Update client state
  Updates client state

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - client_state_update_request (ClientStateUpdateRequest): Updates client state for every subsequent webhook
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec client_state_update(Tesla.Env.client, String.t, TelnyxAPI.Model.ClientStateUpdateRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def client_state_update(connection, call_control_id, client_state_update_request, _opts \\ []) do
    %{}
    |> method(:put)
    |> url("/calls/#{call_control_id}/actions/client_state_update")
    |> add_param(:body, :body, client_state_update_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end

  @doc """
  Remove call from a queue
  Removes the call from a queue.

  ## Parameters

  - connection (TelnyxAPI.Connection): Connection to server
  - call_control_id (String.t): Unique identifier and token for controlling the call
  - leave_queue_request (LeaveQueueRequest): Removes the call from the queue, the call currently is enqueued in.
  - opts (KeywordList): [optional] Optional parameters
  ## Returns

  {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec leave_queue(Tesla.Env.client, String.t, TelnyxAPI.Model.LeaveQueueRequest.t, keyword()) :: {:ok, TelnyxAPI.Model.Errors.t} | {:ok, TelnyxAPI.Model.CallControlCommandResponse.t} | {:error, Tesla.Env.t}
  def leave_queue(connection, call_control_id, leave_queue_request, _opts \\ []) do
    %{}
    |> method(:post)
    |> url("/calls/#{call_control_id}/actions/leave_queue")
    |> add_param(:body, :body, leave_queue_request)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %TelnyxAPI.Model.CallControlCommandResponse{}},
      { :default, %TelnyxAPI.Model.Errors{}}
    ])
  end
end
